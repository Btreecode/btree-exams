questions:
  - question: |
      The following procedure is intended to return the **count** of all odd numbers in a list.
      ```
      PROCEDURE countOdds(numList) {
        count ← 0
        FOR EACH num IN numList {
          IF (num MOD 2 = 0) {
            count ← count + 1
          }
        }
        RETURN (count)
      }
      ```

      Which change will make the procedure work as intended?
    correct_options:
      - Change (num MOD 2 = 0) to (num MOD 2 = 1)
    wrong_options:
      - Change count ← 0 to count ← 1
      - Change count ← count + 1 to count ← num
      - Change num MOD 2 = 0 to num MOD 2 = 2
    explanation: |
      - To check if a number is odd, you check if the remainder when divided by 2 is 1, not 0.

  - question: |
      The following procedure is intended to return the **product** of all numbers in a list, but it currently has a logic error.
      ```
      PROCEDURE getProduct(numList) {
        result ← 0
        FOR EACH num IN numList {
          result ← result * num
        }
        RETURN (result)
      }
      ```

      Which change will make the procedure work as intended?
    correct_options:
      - Change result ← 0 to result ← 1
    wrong_options:
      - Change result * num to result + num
      - Change FOR EACH to REPEAT UNTIL with an index variable.
      - Change RETURN (result) to DISPLAY (result)
    explanation: |
      - Multiplying any number by 0 results in 0. The identity for multiplication should be 1.

  - question: |
      The following procedure is intended to find the **maximum** value in a list of positive integers.
      ```
      PROCEDURE findMax(numList) {
        max ← 0
        FOR EACH num IN numList {
          IF (num < max) {
            max ← num
          }
        }
        RETURN (max)
      }
      ```

      Which change will make the procedure work as intended?
    correct_options:
      - Change (num < max) to (num > max)
    wrong_options:
      - Change max ← 0 to max ← -1
      - Change max ← num to num ← max
      - Change numList to numList[1]
    explanation: |
      - To find the maximum, the condition should check if the current number is *greater* than the current max.
  - question: |
      Consider the following code segment:
      ```
      list ← [10, 5, 20, 15, 30, 25]
      result ← 0
      i ← 1
      REPEAT UNTIL (i > LENGTH(list)) {
        IF (list[i] < list[i + 1]) {
          result ← result + 1
        }
        i ← i + 2
      }
      DISPLAY(result)
      ```

      What is displayed when this code runs?
    correct_options:
      - 0
    wrong_options:
      - 1
      - 2
      - 3
      - None of the above
    explanation: |
      - The loop checks pairs (1,2), (3,4), and (5,6): 10 < 5 (false), 20 < 15 (false), 30 < 25 (false). No pair satisfies the condition, so result remains 0.

  - question: |
      A student wrote the following procedure to find the largest number in a list. The procedure does NOT work correctly for all inputs.
      ```
      PROCEDURE findMax(myList) {
        max ← 0
        index ← 1
        REPEAT UNTIL (index > LENGTH(myList)) {
          IF (myList[index] > max) {
            max ← myList[index]
            RETURN (max)
          }
          index ← index + 1
        }
        RETURN (max)
      }
      ```

      If findMax([3, 8, 2, 10]) is called, what will be returned?
    correct_options:
      - 3
    wrong_options:
      - 8
      - 10
      - 0
      - None of the above
    explanation: |
      - Because the RETURN statement is inside the IF block, the procedure exits as soon as it finds the first value larger than 0.
  - question: |
      A student wrote the following procedure to find the largest number in a list. The procedure does NOT work correctly for all inputs.
      ```
      PROCEDURE findMax(myList) {
        max ← 0
        index ← 1
        REPEAT UNTIL (index > LENGTH(myList)) {
          IF (myList[index] > max) {
            max ← myList[index]
          }
          index ← index + 1
        }
        RETURN (max)
      }
      ```

      In what case would this procedure fail to return the correct maximum value?

    correct_options:
      - If the list contains only negative numbers
    wrong_options:
      - If the list contains at least one positive number
      - If the list contains at least one negative number
      - If the list contains only positive numbers
      - In the list contains only zeros
    explanation: |
      - Since max is initialized to 0, if all numbers in the list are negative, none will be greater than max, and the procedure will incorrectly return 0 instead of the actual maximum (which would be the least negative number).

  - question: |
      A programmer wants to count how many times the word "Apple" appears in a list of fruits. They use the following code:
      ```
      count ← 0
      FOR EACH item IN fruitList {
        IF (item = "Apple") {
          count ← count + 1
          RETURN (count)
        }
      }
      DISPLAY(count)
      ```
      What is the issue with this code?
    correct_options:
      - The RETURN statement inside the loop will cause the program to stop after the first "Apple" is found.
    wrong_options:
      - The count variable should be initialized to 1 instead of 0.
      - The FOR EACH loop cannot be used with string comparisons.
      - The condition in the IF statement should use the MOD operator.
    explanation: |
      - Placing a return statement inside a loop that is meant to count items will prematurely end the loop and the procedure.

  - question: |
      Which of the following is a primary benefit of using **procedural abstraction** in a large software project?
    correct_options:
      - It allows a programmer to use a complex function by knowing only what it does, rather than how it works.
    wrong_options:
      - It ensures that the code will execute faster on all hardware.
      - It prevents other programmers from being able to read the source code.
      - It reduces the amount of memory (RAM) the program requires.
    explanation: |
      - Abstraction focuses on "what" a procedure does, hiding the "how" (implementation details) to reduce complexity for the programmer.

  - question: |
      Consider two algorithms for sorting a list of $n$ names. Algorithm 1 takes $n^2$ steps, and Algorithm 2 takes $n \log n$ steps. Which statement is true regarding their efficiency?
    correct_options:
      - Algorithm 2 is more efficient than Algorithm 1 as the size of the list increases.
    wrong_options:
      - Algorithm 1 is more efficient because it uses simpler mathematical operations.
      - Both algorithms have unreasonable runtimes for large values of $n$.
      - Efficiency cannot be determined without knowing the specific programming language used.
    explanation: |
      - $n \log n$ grows much slower than $n^2$, making Algorithm 2 significantly faster for large datasets.

  - question: |
      Which of the following Boolean expressions is equivalent to **NOT (x OR y)** according to De Morgan's Laws?
    correct_options:
      - (NOT x) AND (NOT y)
    wrong_options:
      - (NOT x) OR (NOT y)
      - x AND y
      - NOT x AND y
    explanation: |
      - De Morgan's Laws state that the negation of a disjunction (OR) is the conjunction (AND) of the negations.

  - question: |
      What value is displayed after the following code executes?
      ```
      total ← 0
      FOR i ← 1 TO 4 {
        FOR j ← 1 TO 2 {
          total ← total + i
        }
      }
      DISPLAY(total)
      ```
    correct_options:
      - 20
    wrong_options:
      - 8
      - 10
      - 16
    explanation: |
      - The inner loop runs twice for each $i$. Total = $2(1) + 2(2) + 2(3) + 2(4) = 2 + 4 + 6 + 8 = 20$.

  - question: |
      A programmer is comparing two algorithms to find a target value in a list of $n$ items. Algorithm X is a linear search, and Algorithm Y is a binary search. Under which condition is Algorithm Y guaranteed to be more efficient?
    correct_options:
      - When the list is very large and the data is already sorted.
    wrong_options:
      - When the list is unsorted and the target is at the very end.
      - When the list contains only string data.
      - Algorithm Y is always less efficient because it requires more complex logic.
    explanation: |
      - Binary search has logarithmic efficiency $O(\log n)$, which is vastly superior to linear search $O(n)$ for large, sorted datasets.
  - question: |
      Which of the following is the best definition of an **undecidable problem** in computer science?
    correct_options:
      - A problem for which no algorithm can be built that always leads to a correct yes-or-no answer.
    wrong_options:
      - A problem that takes an unreasonable amount of time to solve as the input size increases.
      - A problem that has more than one correct solution depending on the input.
      - A problem that can only be solved by a supercomputer or parallel processing.
    explanation: |
      - Undecidable problems, like the Halting Problem, are those for which a general algorithm to solve them for all possible inputs is mathematically proven to be impossible.

  - question: |
      A programmer is trying to write a tool that analyzes any other program and determines if that program will eventually stop or if it will run forever (an infinite loop). This is an example of:
    correct_options:
      - An undecidable problem.
    wrong_options:
      - An algorithmic efficiency problem.
      - A syntax error.
      - A heuristic solution.
    explanation: |
      - This is known as the Halting Problem, which is a classic example of a problem that cannot be solved by any algorithm.

  - question: |
      Which of the following problems is considered **decidable**?
    correct_options:
      - Determining if a specific integer is a multiple of 7.
    wrong_options:
      - Determining if any arbitrary program will ever print the number 42.
      - Determining if two programs with different code will always result in the same output.
      - Finding a universal algorithm that can tell if any program contains a logic error.
    explanation: |
      - Checking if a number is a multiple of 7 is a simple calculation (MOD 7 = 0) that can be solved by a definitive algorithm every time.
  - question: |
      Consider the following code segment:
      ```
      phrase ← "ALGORITHM"
      result ← ""
      i ← LENGTH(phrase)
      REPEAT UNTIL (i < 1) {
        IF (i MOD 2 = 0) {
          result ← result + phrase[i]
        }
        i ← i - 1
      }
      DISPLAY(result)
      ```

      What is displayed? (Assume 1-based indexing)
    correct_options:
      - "HIOL"
    wrong_options:
      - "MTRGA"
      - "ALGORITHM"
      - "AGIH"
    explanation: |
      - The procedure visits indices 9 down to 1 and appends only even indices: 8(H), 6(I), 4(O), 2(L). The displayed value is "HIOL".

  - question: |
      What is displayed when the following code executes?
      ```
      word ← "COOL"
      output ← ""
      FOR EACH letter IN word {
        output ← letter + output
      }
      DISPLAY(output)
      ```
    correct_options:
      - "LOOC"
    wrong_options:
      - "COOL"
      - "CC O O L L"
      - "L O O C"
    explanation: |
      - This code reverses the string because it adds each new letter to the *front* of the existing result.

  - question: |
      A program iterates through the string "REDUNDANCY" and displays only the characters at indices where (i MOD 3 = 0). What is displayed? (Assume 1-based indexing)
    correct_options:
      - "DNC"
    wrong_options:
      - "RUA"
      - "RDN"
      - "EDN"
    explanation: |
      - "REDUNDANCY" length 10. Indices divisible by 3: 3(D), 6(N), 9(C). Result: "DNC".
  - question: |
      A robot is in the center of a 5x5 grid, at position (3, 3), facing North (up). The following code is executed:
      ```
      REPEAT 3 TIMES {
        MOVE_FORWARD()
        ROTATE_RIGHT()
      }
      ```

      If the robot cannot move off the grid (it stays in the last valid square if it tries), what is its final position and direction?
    correct_options:
      - (4, 3) facing West
    wrong_options:
      - (3, 5) facing North
      - (4, 4) facing East
      - (3, 3) facing South
    explanation: |
      - Start at (3,3) facing North. After three cycles: (3,4) facing East, then (4,4) facing South, then (4,3) facing West.

  - question: |
      A robot is at (1, 1) facing East. The goal is to reach (1, 3). Which code segment will successfully move the robot to the goal?
    correct_options:
      - ROTATE_LEFT() MOVE_FORWARD() MOVE_FORWARD()
    wrong_options:
      - MOVE_FORWARD() MOVE_FORWARD()
      - ROTATE_RIGHT() MOVE_FORWARD() MOVE_FORWARD()
      - REPEAT 3 TIMES { MOVE_FORWARD() }
    explanation: |
      - Since the robot is at (1,1) facing East, and needs to get to (1,3), it must first turn North (left) and then move forward two squares.

  - question: |
      Which of the following must be true for a **Binary Search** algorithm to successfully find a target value in a list of 1,000 elements?
    correct_options:
      - The elements in the list must be in sorted order.
    wrong_options:
      - The list must not contain any duplicate values.
      - The target value must be located in the middle of the list.
      - The list must contain only numerical data, not strings.
    explanation: |
      - Binary search works by repeatedly dividing the search interval in half, which is only possible if the data is sorted.
  - question: |
      A procedure `calculateTax(price, rate)` is used in several different parts of a large retail software system. If the government changes the tax rate, the programmer only needs to update the logic inside this one procedure. This is an example of:
    correct_options:
      - Modularity and Abstraction.
    wrong_options:
      - Data compression.
      - A phishing attack.
      - Binary representation.
    explanation: |
      - By isolating specific logic into a procedure (modularity), you manage complexity and make the code easier to maintain and update.
  - question: |
      What is displayed when the following code executes?

      ```
      nums ← [1, 3, 5, 7, 9]
      result ← 0
      FOR EACH n IN nums {
        IF (n > 4) {
          result ← result + n
        }
      }
      DISPLAY(result)
      ```
    correct_options:
      - 21
    wrong_options:
      - 9
      - 25
      - 15
    explanation: |
      - The loop iterates through the list. Only 5, 7, and 9 are greater than 4. The sum of these values is 5 + 7 + 9 = 21.

  - question: |
      Consider the following code segment:
      ```
      x ← 10
      y ← 20
      temp ← x
      x ← y
      y ← temp
      DISPLAY(x)
      DISPLAY(y)
      ```

      What is the result of the code?
    correct_options:
      - 20, 10
    wrong_options:
      - 10, 20
      - 20, 20
      - 10, 10
    explanation: |
      - This is a standard "swap" algorithm. `temp` holds 10, `x` becomes 20, and then `y` takes the value from `temp` (10).

  - question: |
      A programmer is testing a procedure that finds the average of a list of numbers. Which of the following would be the most important **edge case** to test to prevent a program crash?
    correct_options:
      - An empty list (a list with a length of 0).
    wrong_options:
      - A list containing only positive integers.
      - A list with exactly 100 elements.
      - A list where all elements are the same value.
    explanation: |
      - Calculating an average involves dividing by the length of the list. If the list is empty, the program may attempt to divide by zero, causing a runtime error.
  - question: |
      A delivery company needs to find the absolute shortest route for a driver to visit 50 different houses. Because calculating every possible route would take years, they use an algorithm that quickly finds a "good enough" route. This is an example of:
    correct_options:
      - A heuristic algorithm.
    wrong_options:
      - An undecidable problem.
      - A binary search.
      - A recursive procedure.
    explanation: |
      - Heuristics are used when finding an exact, optimal solution is computationally "unreasonable" (takes too long). They provide a practical, though not necessarily perfect, result.

  - question: |
      Which of the following is a characteristic of a **heuristic** approach to solving a problem?
    correct_options:
      - It trades accuracy or perfection for speed in order to find a solution in a reasonable amount of time.
    wrong_options:
      - It is guaranteed to find the single best possible solution every time.
      - It can only be used for problems that have a small number of possible inputs.
      - It is a type of hardware upgrade that makes processors run faster.
    explanation: |
      - Heuristics are "rules of thumb" or shortcuts used in complex optimization problems where an exhaustive search is impossible.

  - question: |
      A programmer is writing a library of functions for handling dates and times that can be used across many different apps. This practice of organizing code into reusable, functional units is known as:
    correct_options:
      - Modularity.
    wrong_options:
      - Redundancy.
      - Lossy compression.
      - Crowdsourcing.
    explanation: |
      - Modularity involves breaking a program into separate sub-programs (modules), making the code easier to test, reuse, and maintain.
  - question: |
      A programmer writes the following procedure to count how many numbers in a list are **strictly greater than 50**.

      ```
      PROCEDURE countHigh(myList) {
        count ← 0
        FOR EACH num IN myList {
          IF (num ≥ 50) {
            count ← count + 1
          }
        }
        RETURN(count)
      }
      ```

      Which of the following best describes the error in the procedure?
    correct_options:
      - The condition includes 50, but it should exclude it.
    wrong_options:
      - The count variable should be initialized to 1.
      - The loop should use a REPEAT UNTIL structure instead of FOR EACH.
      - The procedure should return "num" instead of "count".
    explanation: |
      - The goal was "strictly greater than 50" ($>$), but the code uses "greater than or equal to" ($\geq$), which would incorrectly count the number 50 itself.

  - question: |
      What is the value of **result** after the following code executes?
      ```
      a ← 15
      b ← 4
      result ← (a MOD b) + (a / b)
      ```

      (Note: Assume integer division where 15 / 4 = 3)
    correct_options:
      - 6
    wrong_options:
      - 7
      - 3
      - 4
    explanation: |
      - 15 MOD 4 = 3 (the remainder). 15 / 4 = 3 (the quotient). 3 + 3 = 6.

  - question: |
      A programmer wants to display only the **even** numbers from a list called `valList`. Which of the following code segments should be placed inside the loop?
    correct_options:
      - IF (val MOD 2 = 0) { DISPLAY(val) }
    wrong_options:
      - IF (val MOD 2 = 1) { DISPLAY(val) }
      - IF (val / 2 = 0) { DISPLAY(val) }
      - IF (val = 2) { DISPLAY(val) }
    explanation: |
      - An even number is any number that has a remainder of 0 when divided by 2.
  - question: |
      A developer wants to integrate live weather data into their custom travel app without building their own weather stations. They use a service provided by a third party that allows their app to "ask" for the temperature in a specific city. This service is known as:
    correct_options:
      - An Application Programming Interface (API).
    wrong_options:
      - A Compiler.
      - A Metadata tag.
      - A Heuristic.
    explanation: |
      - An API is a set of rules and protocols that allows one software application to interact with and use the features or data of another service.

  - question: |
      What is displayed after the following code runs?
      ```
      list ← ["red", "green", "blue"]
      i ← LENGTH(list)
      result ← ""
      REPEAT UNTIL (i < 1) {
        result ← result + list[i]
        i ← i - 1
      }
      DISPLAY(result)
      ```
    correct_options:
      - "bluegreenred"
    wrong_options:
      - "redgreenblue"
      - "bluegreen"
      - ""
    explanation: |
      - The loop starts at the end of the list (index 3). It adds "blue", then "green" (index 2), then "red" (index 1), resulting in the reversed concatenation "bluegreenred".

  - question: |
      A programmer is using a text-to-speech API. Which of the following best describes the benefit of using this API rather than writing the code themselves?
    correct_options:
      - It provides a high-level abstraction that allows the programmer to use complex functionality without knowing the underlying code.
    wrong_options:
      - It ensures the program will never have any syntax errors.
      - It makes the final program file size much larger.
      - It prevents the program from needing an internet connection.
    explanation: |
      - APIs are a form of abstraction; they hide the complexity of the service (like processing audio) behind a simple set of commands.
  - question: |
      A student writes the following procedure to calculate the average of a list of numbers:
      ```
      PROCEDURE getAverage(numList) {
        sum ← 0
        FOR EACH num IN numList {
          sum ← sum + num
        }
        RETURN (sum / LENGTH(numList))
      }
      ```

      The code works perfectly for most inputs but crashes when the user provides an empty list `[]`. What type of error is this?
    correct_options:
      - A runtime error.
    wrong_options:
      - A syntax error.
      - A logic error.
      - An overflow error.
    explanation: |
      - Dividing by the length of an empty list results in division by zero. Since the code is syntactically correct but crashes during execution, it is a runtime error.

  - question: |
      Which of the following is the BEST example of using **abstraction** to manage complexity in a program?
    correct_options:
      - Creating a procedure called `drawHouse()` that handles all the geometry and color logic internally.
    wrong_options:
      - Using very long variable names to describe exactly what every number represents.
      - Copying and pasting the same 50 lines of code every time you need to perform a calculation.
      - Writing a single 1,000-line main program without using any functions or procedures.
    explanation: |
      - Abstraction allows you to wrap complex logic into a single, high-level command, making the overall program much easier to read and maintain.

  - question: |
      A programmer is building a game and creates a procedure `moveCharacter(direction, distance)`. Why is this considered an example of abstraction?
    correct_options:
      - It allows the rest of the program to move the player without needing to know the specific coordinate math used inside the procedure.
    wrong_options:
      - It makes the character move faster than if the code were written outside of a procedure.
      - It prevents the player from ever losing the game.
      - It allows the program to run without needing an internet connection.
    explanation: |
      - Procedural abstraction "hides" the messy implementation details, providing a simple interface for the rest of the program to interact with.
  - question: |
      What is displayed after the following code executes?
      ```
      x ← 32
      count ← 0
      REPEAT UNTIL (x < 1) {
        x ← x / 2
        count ← count + 1
      }
      DISPLAY(count)
      ```
    correct_options:
      - 6
    wrong_options:
      - 5
      - 32
      - 7
    explanation: |
      - The values of x will be: 16 (count=1), 8 (count=2), 4 (count=3), 2 (count=4), 1 (count=5), 0.5 (count=6). At 0.5, the condition (x < 1) is finally true, and the loop terminates.

  - question: |
      What is the final value of **sum** after the following code segment is executed?
      ```
      sum ← 0
      n ← 1
      REPEAT 4 TIMES {
        sum ← sum + n
        n ← n * 2
      }
      ```
    correct_options:
      - 15
    wrong_options:
      - 8
      - 16
      - 10
    explanation: |
      - Iteration 1: sum=1, n=2. Iteration 2: sum=3, n=4. Iteration 3: sum=7, n=8. Iteration 4: sum=15, n=16.

  - question: |
      Select TWO answers.
      Which of the following statements about **algorithms** are TRUE?
    correct_options:
      - An algorithm is a step-by-step procedure designed to perform a specific task or solve a problem.
      - Two different algorithms can solve the same problem, but one may be significantly more efficient than the other.
    wrong_options:
      - An algorithm must be written in a specific programming language like Python to be considered valid.
      - All algorithms are guaranteed to finish running in a reasonable amount of time, regardless of the input size.
    explanation: |
      - Algorithms are conceptual steps and can vary in efficiency. They are not tied to one language, and some (unreasonable) algorithms take too long to finish.
  - question: |
      What is displayed after the following code executes?
      ```
      x ← 32
      count ← 0
      REPEAT UNTIL (x < 1) {
        x ← x / 2
        count ← count + 1
      }
      DISPLAY(count)
      ```
    correct_options:
      - 6
    wrong_options:
      - 5
      - 32
      - 7
    explanation: |
      - The values of x will be: 16 (count=1), 8 (count=2), 4 (count=3), 2 (count=4), 1 (count=5), 0.5 (count=6). At 0.5, the condition (x < 1) is finally true, and the loop terminates.

  - question: |
      What is the final value of **sum** after the following code segment is executed?
      ```
      sum ← 0
      n ← 1
      REPEAT 4 TIMES {
        sum ← sum + n
        n ← n * 2
      }
      ```
    correct_options:
      - 15
    wrong_options:
      - 8
      - 16
      - 10
    explanation: |
      - Iteration 1: sum=1, n=2. Iteration 2: sum=3, n=4. Iteration 3: sum=7, n=8. Iteration 4: sum=15, n=16.

  - question: |
      Consider the following Boolean expression, where **score** is an integer:

      (score > 70) AND (NOT (score > 90))

      Which of the following values for **score** would make the expression evaluate to **true**?
    correct_options:
      - 85
    wrong_options:
      - 65
      - 95
      - 70
    explanation: |
      - To be true, the score must be greater than 70 (True) AND not greater than 90 (True). 85 is the only value that fits both criteria.
  - question: |
      Select TWO answers.
      A programmer is designing a social media feed algorithm. Which of the following are ways that **bias** could unintentionally be introduced into the system?
    correct_options:
      - The training data used to develop the algorithm consists only of posts from a specific demographic of users.
      - The developers prioritize "engagement" (clicks/likes) as a metric, which may inadvertently promote controversial or inflammatory content.
    wrong_options:
      - The algorithm is written in a high-level programming language that is used by developers all over the world.
      - The code is peer-reviewed by multiple engineers before being deployed to the live site.
    explanation: |
      - Bias usually enters via unrepresentative data or through the specific mathematical goals (metrics) set by the creators.
  - question: |
      Select TWO answers.
      Which of the following are benefits of using **procedural abstraction** in a large software project?
    correct_options:
      - It allows complex programs to be broken down into smaller, more manageable parts that are easier to test and debug.
      - It promotes code reuse, as a single procedure can be called from multiple locations throughout the program.
    wrong_options:
      - It ensures that the final program will consume less battery power on mobile devices.
      - It eliminates the need for any other form of documentation, such as comments or README files.
    explanation: |
      - Procedural abstraction is about managing complexity and efficiency in the development process, not necessarily hardware performance or eliminating the need for documentation.

  - question: |
      Select TWO answers.
      A team of programmers is refactoring a long, messy script into several well-defined procedures. Which of the following are likely results of this process?
    correct_options:
      - The code becomes easier for other programmers to read and understand.
      - If a bug is found in a specific calculation, it only needs to be fixed in one procedure rather than in multiple places.
    wrong_options:
      - The program's total number of lines of code will always decrease significantly.
      - The program will no longer require an internet connection to run.
    explanation: |
      - Abstraction improves readability and maintainability. While it *can* reduce code length by removing duplication, its primary goal is clarity and "single-point-of-failure" logic fixing.
  - question: |
      Consider the following code segment.
      ```
      val ← 25
      IF (val > 10) {
        IF (val < 20) {
          DISPLAY("Blue")
        } ELSE {
          DISPLAY("Green")
        }
      } ELSE {
        DISPLAY("Red")
      }
      ```

      What is displayed when this code executes?
    correct_options:
      - "Green"
    wrong_options:
      - "Blue"
      - "Red"
      - Nothing is displayed.
    explanation: |
      - First, 25 > 10 is true, so we enter the first IF block. Then, 25 < 20 is false, so we execute the ELSE block, which displays "Green."

  - question: |
      Which of the following describes a **heuristic** approach to finding the shortest path between two points on a map with thousands of intersections?
    correct_options:
      - An algorithm that always chooses the road that points most directly toward the destination, even if it might not lead to the absolute shortest path.
    wrong_options:
      - An algorithm that calculates the distance of every possible combination of roads to find the single shortest one.
      - An algorithm that randomly selects roads until it eventually reaches the destination.
      - An algorithm that refuses to run if there are more than 100 intersections.
    explanation: |
      - Heuristics provide a "good enough" or approximate solution quickly when finding the perfect solution is computationally too expensive or slow.

  - question: |
      A student wants to create a procedure that returns the average of three numbers. Which of the following is a correct implementation using **procedural abstraction**?
    correct_options:
      - |
        ```
        PROCEDURE getAvg(a, b, c) {
          RETURN ( (a + b + c) / 3 )
        }
        ```
    wrong_options:
      - |
        ```
        PROCEDURE getAvg(a, b, c) {
          DISPLAY ( (a + b + c) / 3 )
        }
        ```
      - |
        ```
        PROCEDURE getAvg(a, b, c) {
          sum ← a + b + c
        }
        ```
      - |
        ```
        PROCEDURE getAvg(a, b, c) {
          RETURN ( a + b + c / 3 )
        }
        ```
    explanation: |
      - A procedure used for a calculation should typically return the value to the caller. The math must also use parentheses to ensure the addition happens before the division.
  - question: |
      Consider the following code segment.
      ```
      val ← 25
      IF (val > 10) {
        IF (val < 20) {
          DISPLAY("Blue")
        } ELSE {
          DISPLAY("Green")
        }
      } ELSE {
        DISPLAY("Red")
      }
      ```
      What is displayed when this code executes?
    correct_options:
      - "Green"
    wrong_options:
      - "Blue"
      - "Red"
      - Nothing is displayed.
    explanation: |
      - First, 25 > 10 is true, so we enter the first IF block. Then, 25 < 20 is false, so we execute the ELSE block, which displays "Green."

  - question: |
      The list `temps` contains daily temperatures. Which algorithm correctly counts how many temperatures are greater than 90?
    correct_options:
      - |
        ```
        count ← 0
        FOR EACH t IN temps {
          IF (t > 90) {
            count ← count + 1
          }
        }
        ```
    wrong_options:
      - |
        ```
        count ← 1
        FOR EACH t IN temps {
          IF (t > 90) {
            count ← count + 1
          }
        }
        ```
      - |
        ```
        count ← 0
        FOR EACH t IN temps {
          IF (t > 90) {
            count ← t
          }
        }
        ```
      - |
        ```
        count ← 0
        FOR EACH t IN temps {
          IF (t < 90) {
            count ← count + 1
          }
        }
        ```
    explanation: |
      - The correct algorithm initializes count to 0, checks the intended condition `t > 90`, and increments by 1 for each matching value.

  - question: |
      A sorted list has 1,024 elements. A binary search is used to find a target value. In the worst case, about how many elements are examined?
    correct_options:
      - 10
    wrong_options:
      - 32
      - 128
      - 512
    explanation: |
      - Binary search halves the search space each step. Since $2^{10}=1024$, the worst case is about 10 checks.

  - question: |
      Consider the code segment:
      ```
      values ← [4, 7, 1, 9]
      i ← 1
      total ← 0
      REPEAT UNTIL (i > LENGTH(values)) {
        total ← total + values[i]
        i ← i + 1
      }
      DISPLAY(total)
      ```
      What is displayed?
    correct_options:
      - 21
    wrong_options:
      - 20
      - 17
      - 9
    explanation: |
      - The loop sums all four list elements: $4+7+1+9=21$.

  - question: |
      A programmer wants a procedure that returns true when `n` is divisible by both 2 and 3. Which condition should be used?
    correct_options:
      - "(n MOD 2 = 0) AND (n MOD 3 = 0)"
    wrong_options:
      - "(n MOD 2 = 0) OR (n MOD 3 = 0)"
      - "(n MOD 6 = 1)"
      - "(n / 2 = 0) AND (n / 3 = 0)"
    explanation: |
      - Divisible by both values requires both remainder checks to be 0 and combined with AND.

  - question: |
      Two algorithms solve the same task. Algorithm A always finds the exact best answer but may take hours. Algorithm B usually finds a near-best answer in seconds. Which statement best describes Algorithm B?
    correct_options:
      - It is a heuristic that trades optimality for speed.
    wrong_options:
      - It is undecidable because it does not always produce an exact optimum.
      - It is invalid because all algorithms must produce optimal answers.
      - It is equivalent to binary search.
    explanation: |
      - Heuristic approaches are used when exact solutions are too costly; they prioritize practical runtime over guaranteed optimality.

  - question: |
      Consider the following procedure:
      ```
      PROCEDURE mystery(n) {
        count ← 0
        REPEAT UNTIL (n = 0) {
          n ← n - 1
          count ← count + 1
        }
        RETURN(count)
      }
      ```
      What value does `mystery(5)` return?
    correct_options:
      - 5
    wrong_options:
      - 4
      - 0
      - 10
    explanation: |
      - The loop runs once per decrement from 5 down to 0, so count is incremented 5 times.

  - question: |
      A programmer needs to determine whether a value appears in an unsorted list. Which algorithmic approach is appropriate?
    correct_options:
      - Linear search through the list from start to end.
    wrong_options:
      - Perform the binary search.
      - Checking only the middle element.
      - Using random guessing until the value is found.
      - Two of the above are correct.
    explanation: |
      - Binary search requires sorted data; for unsorted data, linear search is the correct general method.

  - question: |
      Which code segment correctly swaps the values of variables `a` and `b`?
    correct_options:
      - |
        ```
        temp ← a
        a ← b
        b ← temp
        ```
    wrong_options:
      - |
        ```
        a ← b
        b ← a
        ```
      - |
        ```
        a ← temp
        b ← a
        temp ← b
        ```
      - |
        ```
        a ← a
        b ← b
        ```
    explanation: |
      - A temporary variable preserves one value during assignment so neither original value is lost.
