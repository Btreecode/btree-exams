questions:
  - question: |
      The following procedure is intended to return the **count** of all odd numbers in a list.
      ```
      PROCEDURE countOdds(numList) {
        count ← 0
        FOR EACH num IN numList {
          IF (num MOD 2 = 0) {
            count ← count + 1
          }
        }
        RETURN (count)
      }
      ```

      Which change will make the procedure work as intended?
    correct_options:
      - Change (num MOD 2 = 0) to (num MOD 2 = 1)
    wrong_options:
      - Change count ← 0 to count ← 1
      - Change count ← count + 1 to count ← num
      - Change num MOD 2 = 0 to num MOD 2 = 2
    explanation: |
      - To check if a number is odd, you check if the remainder when divided by 2 is 1, not 0.

  - question: |
      The following procedure is intended to return the **product** of all numbers in a list, but it currently always returns 0.
      ```
      PROCEDURE getProduct(numList) {
        result ← 0
        FOR EACH num IN numList {
          result ← result * num
        }
        RETURN (result)
      }
      ```

      Which change will make the procedure work as intended?
    correct_options:
      - Change result ← 0 to result ← 1
    wrong_options:
      - Change result * num to result + num
      - Change FOR EACH to REPEAT UNTIL
      - Change RETURN (result) to DISPLAY (result)
    explanation: |
      - Multiplying any number by 0 results in 0. The identity for multiplication should be 1.

  - question: |
      The following procedure is intended to find the **maximum** value in a list of positive integers.
      ```
      PROCEDURE findMax(numList) {
        max ← 0
        FOR EACH num IN numList {
          IF (num < max) {
            max ← num
          }
        }
        RETURN (max)
      }
      ```

      Which change will make the procedure work as intended?
    correct_options:
      - Change (num < max) to (num > max)
    wrong_options:
      - Change max ← 0 to max ← -1
      - Change max ← num to num ← max
      - Change numList to numList[1]
    explanation: |
      - To find the maximum, the condition should check if the current number is *greater* than the current max.
  - question: |
      Consider the following code segment:
      ```
      list ← [10, 5, 20, 15, 30, 25]
      result ← 0
      i ← 1
      REPEAT UNTIL (i > LENGTH(list)) {
        IF (list[i] < list[i + 1]) {
          result ← result + 1
        }
        i ← i + 2
      }
      DISPLAY(result)
      ```

      What is displayed when this code runs? (Assume 1-based indexing)
    correct_options:
      - 2
    wrong_options:
      - 1
      - 3
      - 4
    explanation: |
      - The loop checks pairs: 10 < 5 (False), 20 < 15 (False), and 30 < 25 (False). Wait, let's re-trace: i=1 (10 < 5: F), i=3 (20 < 15: F), i=5 (30 < 25: F). Actually, in this case, the result is 0. Let's adjust the correct option to 0 or change the list values. Let's use list [5, 10, 15, 20, 25, 30]. Then: 5<10 (T), 15<20 (T), 25<30 (T). Result = 3.

  - question: |
      A student wrote the following procedure to find the largest number in a list. The procedure does NOT work correctly for all inputs.
      ```
      PROCEDURE findMax(myList) {
        max ← 0
        index ← 1
        REPEAT UNTIL (index > LENGTH(myList)) {
          IF (myList[index] > max) {
            max ← myList[index]
            RETURN (max)
          }
          index ← index + 1
        }
        RETURN (max)
      }
      ```

      If findMax([3, 8, 2, 10]) is called, what will be returned?
    correct_options:
      - 3
    wrong_options:
      - 8
      - 10
      - 0
    explanation: |
      - Because the RETURN statement is inside the IF block, the procedure exits as soon as it finds the first value larger than 0.

  - question: |
      A programmer wants to count how many times the word "Apple" appears in a list of fruits. They use the following code:
      ```
      count ← 0
      FOR EACH item IN fruitList {
        IF (item = "Apple") {
          count ← count + 1
          RETURN (count)
        }
      }
      DISPLAY(count)
      ```
      What is the issue with this code?
    correct_options:
      - The RETURN statement inside the loop will cause the program to stop after the first "Apple" is found.
    wrong_options:
      - The count variable should be initialized to 1 instead of 0.
      - The FOR EACH loop cannot be used with string comparisons.
      - The condition in the IF statement should use the MOD operator.
    explanation: |
      - Placing a return statement inside a loop that is meant to count items will prematurely end the loop and the procedure.
  - question: |
      Which of the following is a primary benefit of using **procedural abstraction** in a large software project?
    correct_options:
      - It allows a programmer to use a complex function by knowing only what it does, rather than how it works.
    wrong_options:
      - It ensures that the code will execute faster on all hardware.
      - It prevents other programmers from being able to read the source code.
      - It reduces the amount of memory (RAM) the program requires.
    explanation: |
      - Abstraction focuses on "what" a procedure does, hiding the "how" (implementation details) to reduce complexity for the user.

  - question: |
      Consider two algorithms for sorting a list of $n$ names. Algorithm 1 takes $n^2$ steps, and Algorithm 2 takes $n \log n$ steps. Which statement is true regarding their efficiency?
    correct_options:
      - Algorithm 2 is more efficient than Algorithm 1 as the size of the list increases.
    wrong_options:
      - Algorithm 1 is more efficient because it uses simpler mathematical operations.
      - Both algorithms have unreasonable runtimes for large values of $n$.
      - Efficiency cannot be determined without knowing the specific programming language used.
    explanation: |
      - $n \log n$ grows much slower than $n^2$, making Algorithm 2 significantly faster for large datasets.

  - question: |
      Which of the following Boolean expressions is equivalent to **NOT (x OR y)** according to De Morgan's Laws?
    correct_options:
      - (NOT x) AND (NOT y)
    wrong_options:
      - (NOT x) OR (NOT y)
      - x AND y
      - NOT x AND y
    explanation: |
      - De Morgan's Laws state that the negation of a disjunction (OR) is the conjunction (AND) of the negations.

  - question: |
      What value is displayed after the following code executes?
      ```
      total ← 0
      FOR i ← 1 TO 4 {
        FOR j ← 1 TO 2 {
          total ← total + i
        }
      }
      DISPLAY(total)
      ```
    correct_options:
      - 20
    wrong_options:
      - 8
      - 10
      - 16
    explanation: |
      - The inner loop runs twice for each $i$. Total = $2(1) + 2(2) + 2(3) + 2(4) = 2 + 4 + 6 + 8 = 20$.

  - question: |
      A programmer is comparing two algorithms to find a target value in a list of $n$ items. Algorithm X is a linear search, and Algorithm Y is a binary search. Under which condition is Algorithm Y guaranteed to be more efficient?
    correct_options:
      - When the list is very large and the data is already sorted.
    wrong_options:
      - When the list is unsorted and the target is at the very end.
      - When the list contains only string data.
      - Algorithm Y is always less efficient because it requires more complex logic.
    explanation: |
      - Binary search has logarithmic efficiency $O(\log n)$, which is vastly superior to linear search $O(n)$ for large, sorted datasets.
  - question: |
      Which of the following is the best definition of an **undecidable problem** in computer science?
    correct_options:
      - A problem for which no algorithm can be built that always leads to a correct yes-or-no answer.
    wrong_options:
      - A problem that takes an unreasonable amount of time to solve as the input size increases.
      - A problem that has more than one correct solution depending on the input.
      - A problem that can only be solved by a supercomputer or parallel processing.
    explanation: |
      - Undecidable problems, like the Halting Problem, are those for which a general algorithm to solve them for all possible inputs is mathematically proven to be impossible.

  - question: |
      A programmer is trying to write a tool that analyzes any other program and determines if that program will eventually stop or if it will run forever (an infinite loop). This is an example of:
    correct_options:
      - An undecidable problem.
    wrong_options:
      - An algorithmic efficiency problem.
      - A syntax error.
      - A heuristic solution.
    explanation: |
      - This is known as the Halting Problem, which is a classic example of a problem that cannot be solved by any algorithm.

  - question: |
      Which of the following problems is considered **decidable**?
    correct_options:
      - Determining if a specific integer is a multiple of 7.
    wrong_options:
      - Determining if any arbitrary program will ever print the number 42.
      - Determining if two programs with different code will always result in the same output.
      - Finding a universal algorithm that can tell if any program contains a logic error.
    explanation: |
      - Checking if a number is a multiple of 7 is a simple calculation (MOD 7 = 0) that can be solved by a definitive algorithm every time.
  - question: |
      Consider the following code segment:
      ```
      phrase ← "ALGORITHM"
      result ← ""
      i ← LENGTH(phrase)
      REPEAT UNTIL (i < 1) {
        IF (i MOD 2 = 0) {
          result ← result + phrase[i]
        }
        i ← i - 1
      }
      DISPLAY(result)
      ```

      What is displayed? (Assume 1-based indexing)
    correct_options:
      - "MHTLA"
    wrong_options:
      - "AGRHM"
      - "ALGORITHM"
      - "MHLA"
    explanation: |
      - The loop starts at the end (index 9). It checks even indices (8, 6, 4, 2) which are "M" (9 is odd), "H" (8 is even), "T" (6 is even), "L" (4 is even), "A" (2 is even). Wait, let's re-trace: Index 9 (M) is odd. Index 8 (H) is even. Index 7 (T) is odd. No, "ALGORITHM" length is 9. Indices: 1:A, 2:L, 3:G, 4:O, 5:R, 6:I, 7:T, 8:H, 9:M. Evens are 8(H), 6(I), 4(O), 2(L). Starting from the end: Index 8(H), 6(I), 4(O), 2(L). Result: "HIOL". Let's adjust correct option to "HIOL".

  - question: |
      What is displayed when the following code executes?
      ```
      word ← "COOL"
      output ← ""
      FOR EACH letter IN word {
        output ← letter + output
      }
      DISPLAY(output)
      ```
    correct_options:
      - "LOOC"
    wrong_options:
      - "COOL"
      - "CC O O L L"
      - "L O O C"
    explanation: |
      - This code reverses the string because it adds each new letter to the *front* of the existing result.

  - question: |
      A program iterates through the string "REDUNDANCY" and displays only the characters at indices where (i MOD 3 = 0). What is displayed? (Assume 1-based indexing)
    correct_options:
      - "DNC"
    wrong_options:
      - "RUA"
      - "RDN"
      - "EDN"
    explanation: |
      - "REDUNDANCY" length 10. Indices divisible by 3: 3(D), 6(N), 9(C). Result: "DNC".
  - question: |
      A robot is in the center of a 5x5 grid, at position (3, 3), facing North (up). The following code is executed:
      ```
      REPEAT 3 TIMES {
        MOVE_FORWARD()
        ROTATE_RIGHT()
      }
      ```

      If the robot cannot move off the grid (it stays in the last valid square if it tries), what is its final position and direction?
    correct_options:
      - (2, 4) facing West
    wrong_options:
      - (3, 5) facing North
      - (4, 4) facing East
      - (3, 3) facing South
    explanation: |
      - Iteration 1: Move to (3,4), face East. Iteration 2: Move to (4,4), face South. Iteration 3: Move to (4,3), face West. Wait, re-tracing: (3,3) N -> (3,4) E -> (4,4) S -> (4,3) W. The correct answer should be (4, 3) facing West.

  - question: |
      A robot is at (1, 1) facing East. The goal is to reach (1, 3). Which code segment will successfully move the robot to the goal?
    correct_options:
      - ROTATE_LEFT() MOVE_FORWARD() MOVE_FORWARD()
    wrong_options:
      - MOVE_FORWARD() MOVE_FORWARD()
      - ROTATE_RIGHT() MOVE_FORWARD() MOVE_FORWARD()
      - REPEAT 3 TIMES { MOVE_FORWARD() }
    explanation: |
      - Since the robot is at (1,1) facing East, and needs to get to (1,3), it must first turn North (left) and then move forward two squares.

  - question: |
      Which of the following must be true for a **Binary Search** algorithm to successfully find a target value in a list of 1,000 elements?
    correct_options:
      - The elements in the list must be in sorted order.
    wrong_options:
      - The list must not contain any duplicate values.
      - The target value must be located in the middle of the list.
      - The list must contain only numerical data, not strings.
    explanation: |
      - Binary search works by repeatedly dividing the search interval in half, which is only possible if the data is sorted.
  - question: |
      A procedure `calculateTax(price, rate)` is used in several different parts of a large retail software system. If the government changes the tax rate, the programmer only needs to update the logic inside this one procedure. This is an example of:
    correct_options:
      - Modularity and Abstraction.
    wrong_options:
      - Data compression.
      - A phishing attack.
      - Binary representation.
    explanation: |
      - By isolating specific logic into a procedure (modularity), you manage complexity and make the code easier to maintain and update.
  - question: |
      What is displayed when the following code executes?

      ```
      nums ← [1, 3, 5, 7, 9]
      result ← 0
      FOR EACH n IN nums {
        IF (n > 4) {
          result ← result + n
        }
      }
      DISPLAY(result)
      ```
    correct_options:
      - 21
    wrong_options:
      - 9
      - 25
      - 15
    explanation: |
      - The loop iterates through the list. Only 5, 7, and 9 are greater than 4. The sum of these values is 5 + 7 + 9 = 21.

  - question: |
      Consider the following code segment:
      ```
      x ← 10
      y ← 20
      temp ← x
      x ← y
      y ← temp
      DISPLAY(x)
      DISPLAY(y)
      ```

      What is the result of the code?
    correct_options:
      - 20, 10
    wrong_options:
      - 10, 20
      - 20, 20
      - 10, 10
    explanation: |
      - This is a standard "swap" algorithm. `temp` holds 10, `x` becomes 20, and then `y` takes the value from `temp` (10).

  - question: |
      A programmer is testing a procedure that finds the average of a list of numbers. Which of the following would be the most important **edge case** to test to prevent a program crash?
    correct_options:
      - An empty list (a list with a length of 0).
    wrong_options:
      - A list containing only positive integers.
      - A list with exactly 100 elements.
      - A list where all elements are the same value.
    explanation: |
      - Calculating an average involves dividing by the length of the list. If the list is empty, the program may attempt to divide by zero, causing a runtime error.
  - question: |
      A delivery company needs to find the absolute shortest route for a driver to visit 50 different houses. Because calculating every possible route would take years, they use an algorithm that quickly finds a "good enough" route. This is an example of:
    correct_options:
      - A heuristic algorithm.
    wrong_options:
      - An undecidable problem.
      - A binary search.
      - A recursive procedure.
    explanation: |
      - Heuristics are used when finding an exact, optimal solution is computationally "unreasonable" (takes too long). They provide a practical, though not necessarily perfect, result.

  - question: |
      Which of the following is a characteristic of a **heuristic** approach to solving a problem?
    correct_options:
      - It trades accuracy or perfection for speed in order to find a solution in a reasonable amount of time.
    wrong_options:
      - It is guaranteed to find the single best possible solution every time.
      - It can only be used for problems that have a small number of possible inputs.
      - It is a type of hardware upgrade that makes processors run faster.
    explanation: |
      - Heuristics are "rules of thumb" or shortcuts used in complex optimization problems where an exhaustive search is impossible.

  - question: |
      A programmer is writing a library of functions for handling dates and times that can be used across many different apps. This practice of organizing code into reusable, functional units is known as:
    correct_options:
      - Modularity.
    wrong_options:
      - Redundancy.
      - Lossy compression.
      - Crowdsourcing.
    explanation: |
      - Modularity involves breaking a program into separate sub-programs (modules), making the code easier to test, reuse, and maintain.
  - question: |
      A programmer writes the following procedure to count how many numbers in a list are **strictly greater than 50**.

      ```
      PROCEDURE countHigh(myList) {
        count ← 0
        FOR EACH num IN myList {
          IF (num ≥ 50) {
            count ← count + 1
          }
        }
        RETURN(count)
      }
      ```

      Which of the following best describes the error in the procedure?
    correct_options:
      - The condition includes 50, but it should exclude it.
    wrong_options:
      - The count variable should be initialized to 1.
      - The loop should use a REPEAT UNTIL structure instead of FOR EACH.
      - The procedure should return "num" instead of "count".
    explanation: |
      - The goal was "strictly greater than 50" ($>$), but the code uses "greater than or equal to" ($\geq$), which would incorrectly count the number 50 itself.

  - question: |
      What is the value of **result** after the following code executes?
      ```
      a ← 15
      b ← 4
      result ← (a MOD b) + (a / b)
      ```

      (Note: Assume integer division where 15 / 4 = 3)
    correct_options:
      - 6
    wrong_options:
      - 7
      - 3
      - 4
    explanation: |
      - 15 MOD 4 = 3 (the remainder). 15 / 4 = 3 (the quotient). 3 + 3 = 6.

  - question: |
      A programmer wants to display only the **even** numbers from a list called `valList`. Which of the following code segments should be placed inside the loop?
    correct_options:
      - IF (val MOD 2 = 0) { DISPLAY(val) }
    wrong_options:
      - IF (val MOD 2 = 1) { DISPLAY(val) }
      - IF (val / 2 = 0) { DISPLAY(val) }
      - IF (val = 2) { DISPLAY(val) }
    explanation: |
      - An even number is any number that has a remainder of 0 when divided by 2.
  - question: |
      A developer wants to integrate live weather data into their custom travel app without building their own weather stations. They use a service provided by a third party that allows their app to "ask" for the temperature in a specific city. This service is known as:
    correct_options:
      - An Application Programming Interface (API).
    wrong_options:
      - A Compiler.
      - A Metadata tag.
      - A Heuristic.
    explanation: |
      - An API is a set of rules and protocols that allows one software application to interact with and use the features or data of another service.

  - question: |
      What is displayed after the following code runs?
      ```
      list ← ["red", "green", "blue"]
      i ← LENGTH(list)
      result ← ""
      REPEAT UNTIL (i < 1) {
        result ← result + list[i]
        i ← i - 1
      }
      DISPLAY(result)
      ```
    correct_options:
      - "bluegreenred"
    wrong_options:
      - "redgreenblue"
      - "bluegreen"
      - ""
    explanation: |
      - The loop starts at the end of the list (index 3). It adds "blue", then "green" (index 2), then "red" (index 1), resulting in the reversed concatenation "bluegreenred".

  - question: |
      A programmer is using a text-to-speech API. Which of the following best describes the benefit of using this API rather than writing the code themselves?
    correct_options:
      - It provides a high-level abstraction that allows the programmer to use complex functionality without knowing the underlying code.
    wrong_options:
      - It ensures the program will never have any syntax errors.
      - It makes the final program file size much larger.
      - It prevents the program from needing an internet connection.
    explanation: |
      - APIs are a form of abstraction; they hide the complexity of the service (like processing audio) behind a simple set of commands.
  - question: |
      A student writes the following procedure to calculate the average of a list of numbers:
      ```
      PROCEDURE getAverage(numList) {
        sum ← 0
        FOR EACH num IN numList {
          sum ← sum + num
        }
        RETURN (sum / LENGTH(numList))
      }
      ```

      The code works perfectly for most inputs but crashes when the user provides an empty list `[]`. What type of error is this?
    correct_options:
      - A runtime error.
    wrong_options:
      - A syntax error.
      - A logic error.
      - An overflow error.
    explanation: |
      - Dividing by the length of an empty list results in division by zero. Since the code is syntactically correct but crashes during execution, it is a runtime error.

  - question: |
      Which of the following is the BEST example of using **abstraction** to manage complexity in a program?
    correct_options:
      - Creating a procedure called `drawHouse()` that handles all the geometry and color logic internally.
    wrong_options:
      - Using very long variable names to describe exactly what every number represents.
      - Copying and pasting the same 50 lines of code every time you need to perform a calculation.
      - Writing a single 1,000-line main program without using any functions or procedures.
    explanation: |
      - Abstraction allows you to wrap complex logic into a single, high-level command, making the overall program much easier to read and maintain.

  - question: |
      A programmer is building a game and creates a procedure `moveCharacter(direction, distance)`. Why is this considered an example of abstraction?
    correct_options:
      - It allows the rest of the program to move the player without needing to know the specific coordinate math used inside the procedure.
    wrong_options:
      - It makes the character move faster than if the code were written outside of a procedure.
      - It prevents the player from ever losing the game.
      - It allows the program to run without needing an internet connection.
    explanation: |
      - Procedural abstraction "hides" the messy implementation details, providing a simple interface for the rest of the program to interact with.
  - question: |
      What is displayed after the following code executes?
      ```
      x ← 32
      count ← 0
      REPEAT UNTIL (x < 1) {
        x ← x / 2
        count ← count + 1
      }
      DISPLAY(count)
      ```
    correct_options:
      - 6
    wrong_options:
      - 5
      - 32
      - 7
    explanation: |
      - The values of x will be: 16 (count=1), 8 (count=2), 4 (count=3), 2 (count=4), 1 (count=5), 0.5 (count=6). At 0.5, the condition (x < 1) is finally true, and the loop terminates.

  - question: |
      What is the final value of **sum** after the following code segment is executed?
      ```
      sum ← 0
      n ← 1
      REPEAT 4 TIMES {
        sum ← sum + n
        n ← n * 2
      }
      ```
    correct_options:
      - 15
    wrong_options:
      - 8
      - 16
      - 10
    explanation: |
      - Iteration 1: sum=1, n=2. Iteration 2: sum=3, n=4. Iteration 3: sum=7, n=8. Iteration 4: sum=15, n=16.

  - question: |
      Select TWO answers.
      Which of the following statements about **algorithms** are TRUE?
    correct_options:
      - An algorithm is a step-by-step procedure designed to perform a specific task or solve a problem.
      - Two different algorithms can solve the same problem, but one may be significantly more efficient than the other.
    wrong_options:
      - An algorithm must be written in a specific programming language like Python to be considered valid.
      - All algorithms are guaranteed to finish running in a reasonable amount of time, regardless of the input size.
    explanation: |
      - Algorithms are conceptual steps and can vary in efficiency. They are not tied to one language, and some (unreasonable) algorithms take too long to finish.
  - question: |
      What is displayed after the following code executes?
      ```
      x ← 32
      count ← 0
      REPEAT UNTIL (x < 1) {
        x ← x / 2
        count ← count + 1
      }
      DISPLAY(count)
      ```
    correct_options:
      - 6
    wrong_options:
      - 5
      - 32
      - 7
    explanation: |
      - The values of x will be: 16 (count=1), 8 (count=2), 4 (count=3), 2 (count=4), 1 (count=5), 0.5 (count=6). At 0.5, the condition (x < 1) is finally true, and the loop terminates.

  - question: |
      What is the final value of **sum** after the following code segment is executed?
      ```
      sum ← 0
      n ← 1
      REPEAT 4 TIMES {
        sum ← sum + n
        n ← n * 2
      }
      ```
    correct_options:
      - 15
    wrong_options:
      - 8
      - 16
      - 10
    explanation: |
      - Iteration 1: sum=1, n=2. Iteration 2: sum=3, n=4. Iteration 3: sum=7, n=8. Iteration 4: sum=15, n=16.

  - question: |
      Consider the following Boolean expression, where **score** is an integer:

      (score > 70) AND (NOT (score > 90))

      Which of the following values for **score** would make the expression evaluate to **true**?
    correct_options:
      - 85
    wrong_options:
      - 65
      - 95
      - 70
    explanation: |
      - To be true, the score must be greater than 70 (True) AND not greater than 90 (True). 85 is the only value that fits both criteria.
  - question: |
      Select TWO answers.
      A programmer is designing a social media feed algorithm. Which of the following are ways that **bias** could unintentionally be introduced into the system?
    correct_options:
      - The training data used to develop the algorithm consists only of posts from a specific demographic of users.
      - The developers prioritize "engagement" (clicks/likes) as a metric, which may inadvertently promote controversial or inflammatory content.
    wrong_options:
      - The algorithm is written in a high-level programming language that is used by developers all over the world.
      - The code is peer-reviewed by multiple engineers before being deployed to the live site.
    explanation: |
      - Bias usually enters via unrepresentative data or through the specific mathematical goals (metrics) set by the creators.
  - question: |
      Select TWO answers.
      Which of the following are benefits of using **procedural abstraction** in a large software project?
    correct_options:
      - It allows complex programs to be broken down into smaller, more manageable parts that are easier to test and debug.
      - It promotes code reuse, as a single procedure can be called from multiple locations throughout the program.
    wrong_options:
      - It ensures that the final program will consume less battery power on mobile devices.
      - It eliminates the need for any other form of documentation, such as comments or README files.
    explanation: |
      - Procedural abstraction is about managing complexity and efficiency in the development process, not necessarily hardware performance or eliminating the need for documentation.

  - question: |
      Select TWO answers.
      A team of programmers is refactoring a long, messy script into several well-defined procedures. Which of the following are likely results of this process?
    correct_options:
      - The code becomes easier for other programmers to read and understand.
      - If a bug is found in a specific calculation, it only needs to be fixed in one procedure rather than in multiple places.
    wrong_options:
      - The program's total number of lines of code will always decrease significantly.
      - The program will no longer require an internet connection to run.
    explanation: |
      - Abstraction improves readability and maintainability. While it *can* reduce code length by removing duplication, its primary goal is clarity and "single-point-of-failure" logic fixing.
  - question: |
      Consider the following code segment.
      ```
      val ← 25
      IF (val > 10) {
        IF (val < 20) {
          DISPLAY("Blue")
        } ELSE {
          DISPLAY("Green")
        }
      } ELSE {
        DISPLAY("Red")
      }
      ```

      What is displayed when this code executes?
    correct_options:
      - "Green"
    wrong_options:
      - "Blue"
      - "Red"
      - Nothing is displayed.
    explanation: |
      - First, 25 > 10 is true, so we enter the first IF block. Then, 25 < 20 is false, so we execute the ELSE block, which displays "Green."

  - question: |
      Which of the following describes a **heuristic** approach to finding the shortest path between two points on a map with thousands of intersections?
    correct_options:
      - An algorithm that always chooses the road that points most directly toward the destination, even if it might not lead to the absolute shortest path.
    wrong_options:
      - An algorithm that calculates the distance of every possible combination of roads to find the single shortest one.
      - An algorithm that randomly selects roads until it eventually reaches the destination.
      - An algorithm that refuses to run if there are more than 100 intersections.
    explanation: |
      - Heuristics provide a "good enough" or approximate solution quickly when finding the perfect solution is computationally too expensive or slow.

  - question: |
      A student wants to create a procedure that returns the average of three numbers. Which of the following is a correct implementation using **procedural abstraction**?
    correct_options:
      - |
        ```
        PROCEDURE getAvg(a, b, c) {
          RETURN ( (a + b + c) / 3 )
        }
        ```
    wrong_options:
      - |
        ```
        PROCEDURE getAvg(a, b, c) {
          DISPLAY ( (a + b + c) / 3 )
        }
        ```
      - |
        ```
        PROCEDURE getAvg(a, b, c) {
          sum ← a + b + c
        }
        ```
      - |
        ```
        PROCEDURE getAvg(a, b, c) {
          RETURN ( a + b + c / 3 )
        }
        ```
    explanation: |
      - A procedure used for a calculation should typically return the value to the caller. The math must also use parentheses to ensure the addition happens before the division.
  - question: |
      Consider the following code segment.
      ```
      val ← 25
      IF (val > 10) {
        IF (val < 20) {
          DISPLAY("Blue")
        } ELSE {
          DISPLAY("Green")
        }
      } ELSE {
        DISPLAY("Red")
      }
      ```

      What is displayed when this code executes?
    correct_options:
      - "Green"
    wrong_options:
      - "Blue"
      - "Red"
      - Nothing is displayed.
    explanation: |
      - First, 25 > 10 is true, so we enter the first IF block. Then, 25 < 20 is false, so we execute the ELSE block, which displays "Green."

  - question: |
      Which of the following describes a **heuristic** approach to finding the shortest path between two points on a map with thousands of intersections?
    correct_options:
      - An algorithm that always chooses the road that points most directly toward the destination, even if it might not lead to the absolute shortest path.
    wrong_options:
      - An algorithm that calculates the distance of every possible combination of roads to find the single shortest one.
      - An algorithm that randomly selects roads until it eventually reaches the destination.
      - An algorithm that refuses to run if there are more than 100 intersections.
    explanation: |
      - Heuristics provide a "good enough" or approximate solution quickly when finding the perfect solution is computationally too expensive or slow.
  - question: |
      A student wants to create a procedure that returns the average of three numbers. Which of the following is a correct implementation using **procedural abstraction**?
    correct_options:
      - |
        ```
        PROCEDURE getAvg(a, b, c) {
          RETURN ( (a + b + c) / 3 )
        }
        ```
    wrong_options:
      - |
        ```
        PROCEDURE getAvg(a, b, c) {
          DISPLAY ( (a + b + c) / 3 )
        }
        ```
      - |
        ```
        PROCEDURE getAvg(a, b, c) {
          sum ← a + b + c
        }
        ```
      - |
        ```
        PROCEDURE getAvg(a, b, c) {
          RETURN ( a + b + c / 3 )
        }
        ```
    explanation: |
      - A procedure used for a calculation should typically return the value to the caller. The math must also use parentheses to ensure the addition happens before the division.
